Абстрактный класс
В этом задании мы попрактикуемся в наследовании, используя абстрактные классы. Нюхнём ООП, так сказать. Нам нужно выделить общие части компонентов в абстрактный класс AbstractComponent.

Изучите структуру существующих компонентов. Нужно понять, какие логика и данные повторяются и там, и там. Не всегда ответ на этот вопрос очевиден, и порой придется подумать, порисовать, порефакторить. Но если вы описали методы getTemplate, getElement, removeElement, как мы просили в предыдущих заданиях, то общими будут именно они.

Создадим абстрактный класс. Это точно такой же класс, как все остальные, только создавать объекты напрямую из него нельзя. От него можно только наследоваться. Поэтому в конструктор добавим проверку:

class AbstractComponent {
   constructor() {
       if (new.target === AbstractComponent) {
           throw new Error(`Can't instantiate AbstractComponent, only concrete one.`);
       }
   }
}
Далее опишем в нем свойства и методы:

У наследников должен быть обязательно реализован метод getTemplate. Чтобы об этом не забыть, в реализации абстрактного класса мы будем бросать исключение:
getTemplate() {
  throw new Error(`Abstract method not implemented: getTemplate`);
}
приватное свойство _element, методы getElement, removeElement полностью переезжают из компонентов в абстрактный класс.
А теперь унаследуем все наши компоненты от абстрактного класса AbstractComponent с помощью языковой конструкции extends. Отрефакторим их на следующем шаге.

Давайте уберем все то, что уже реализовано в родителе (все том же абстрактном классе AbstractComponent). В этом может помочь ваша IDE или текстовый редактор. Обычно они помечают переопределенные методы. Но в нашем случае как минимум нужно удалить приватное свойство _element, методы getElement и removeElement, потому что их не нужно переопределять. А значит можно использовать полностью родительскую реализацию. А метод getTemplate нужно переопределить. То есть оставить его в компонентах таким же, каким он был изначально. Остальные методы, которые реализованы в наших компонентах останутся без изменений.

Снаружи изменять ничего не придется. Все должно продолжить работать. Но не забудьте в этом убедиться.

Больше абстракций богу абстракций
На этом шаге мы максимально абстрагируемся от работы с DOM напрямую, в пользу работы с нашими компонентами.

У нас появились вспомогательные функции по работе с DOM: render, remove и тд. Вынесите их в отдельный модуль utils/render.js, чтобы не мешать их с другими вспомогательными функциями. А так же измените реализацию этих функций, чтобы в них можно было передавать наши компоненты, а не DOM-элементы, на сколько это возможно.

У нас осталось последнее место, где мы работаем с DOM напрямую — это подписка на события. Откажемся от прямого использования addEventListener в main.js, оставив его только в компонентах. Для этого добавте в компоненты методы, для установки обработчиков событий, а в тело этих методов перенесите использование addEventListener. Глобальные обработчики document.addEventListener остаются как есть.

Было:

component.getElement().querySelector(`form`).addEventListener(`submit`, handler);
Стало:

class Component {
  setSubmitHandler(handler) {
    this.getElement().querySelector(`form`).addEventListener(`submit`, handler);
  }
}

component.setSubmitHandler(handler);
Теперь мы ничего не знаем о внутреннем устройстве компонентов и их реальных событиях. Важным для нас остается лишь их интерфейс — набор методов, которыми они обладают. Мы можем менять разметку и реальные события отдельных компонентов безболезненно для всего приложения. Главное, сохранять интерфейс компонентов.

Контроллер
Пришло время разгрузить main.js и вынести часть связанной логики в отдельную сущность — Контроллер. Задача контроллера создавать компоненты, добавлять их на страницу, навешивать обработчики. То есть реализовывать бизнес-логику и поведение приложения
