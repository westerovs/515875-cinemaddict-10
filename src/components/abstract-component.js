import {createElement} from '../utils/render.js';


// AbstractComponent - класс который описывает интерфейс
export default class AbstractComponent {

  constructor() {
    // если я создаю этот класс(просто дом ноду) с пом. слова new то ошибка, т.к я не могу создавать абстрактные компоненты, мне нужно создавать конкретные компоненты.
    if (new.target === AbstractComponent) {
      throw new Error(`Нельзя использовать абстрактные компоненты, создайте конкретный компонент`);
    }
    // у каджого компонента есть dom елемент, при том что этот элемент является приватным свойством, т.к я не хочу пользоваться этим элементос снаружи
    this._element = null;
  }

  // шаблон
  getTemplate() {
    // если кто-нибудь попытается создать его через конструктор new, то он получит ошибку = я не знаю какой шаблон отрисовать, воспользуйся наследованием и полиморфизмом
    throw new Error(`Не знаю какой шаблон отрисовать. Воспользуйся наследованием и полиморфизмом`);
  }

  // внешний метод для обращ. к dom элементу, для того что бы складывать одни элементы в другие и продолжал описывать логику
  // тетод getElement во всех классах будет идентичен
  // мы вызывает создание элемента на основе шаблона, если этого эл-та не существует. При первом обращении понимает что этого эл-та нет и создаёт его и возвращает и пользуется
  getElement() {
    if (!this._element) {
      this._element = createElement(this.getTemplate());
    }
    return this._element;
  }

  // метод удалить ссылку из дома
  // удаляет ссылку на элемент, т.к
  // если эл-т удаляется из дома, он не исчезает из памяти, если у него не удалить ссылку
  removeElement() {
    this._element = null;
  }
}
